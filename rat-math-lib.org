#+TITLE: Rational Math Library for Forth
#+SUBTITLE: Literate Design
#+AUTHOR: Daniel Birket
#+EMAIL: danielb@birket.com
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

* Introduction

Rational literal numbers (i.e. “fractions”) are entered as an integer
numerator, followed by an integer denominator.  Both are
single-precision signed integers.  For example 0/1 (zero) is entered
as “0 1”.  Forty-one Sevenths (41/7) is entered as “41 7”.  Negative
three halves (-3/2) is entered as “-3 2”.  Fractions appear on the
stack as two cells: the numerator and then the denominator, on “top”.

A zero denominator with any non-zero integer numerator indicates
positive or negative infinity. A zero numerator with a positive or
negative denominator indicates positive or negative zero.  A zero
numerator and zero denominator indicates not-a-number (NaN).

| numer | denom | meaning          |
|-------+-------+------------------|
| +     | +     | + fraction       |
| -     | +     | - fraction       |
| +     | -     | - fraction       |
| -     | -     | + fraction       |
| 0     | +     | 0 or +0          |
| 0     | -     | -0               |
| +     | 0     | + infinity       |
| -     | 0     | - infinity       |
| 0     | 0     | NaN not-a-number |

Fractions can be “reduced” to remove common factors of the numerator
and denominator but that is not required or automatic.  For example, a
fraction of “3 9” (3/9) is fine.  You don’t have to reduce that
fraction to “1 3” (1/3), although you can.  Reduced fractions have
more range than fractions containing unnecessary common factors.

The denominator is positive when normalized but may be negative. When
negative, it negates the fraction.  If both the numerator and
denominator are negative, the fraction is positive.

The file rat-math-lib.fs contains the rational math library:

#+begin_src forth :tangle rat-math-lib.fs
  \ Notation:
  \ num : single-precision signed integer numerator
  \ den : single-precision signed integer denominator
  \ "name" : name from input stream (not stack)
  \ a-addr : address, perhaps from a variable
#+end_src

The file rat-math-lib-tests.fs contains the test suite for the library:

#+begin_src forth :tangle rat-math-lib-tests.fs
  \ Test Suite for rat-math-lib.fs
  : confirm if ." Pass " else ." Fail " bye then ;  \ immediate assert( )

  : 2= ( n1 n2 n3 n4 -- f ) \ rat-test "two-equals"
       \ first two singles equal second two singles ( n1 = n3 AND n2 = n4 )
       swap -rot = -rot = and ;
#+end_src

* Words

This section describes and defines the Forth “words” (functions) used
in the library. Most words are prefixed with “rat”.

** Helpers

These generally useful functions are used by some “rat” functions below.

- GCF “Greatest Common Factor” ::
  Find the positive greatest common factor of two signed non-zero integers.

  #+begin_src forth :tangle rat-math-lib.fs
    : GCF ( n1 n2 -- n ) \ rational "Greatest Common Factor"
      \ Return the positive signed integer greatest common factor of 2 signed non-0 ints
      begin
	?dup
      while
	tuck mod  \ mod naturally swaps n1 n2 when n1 < n2
      repeat
      abs ;
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
    0 0 GCF .s 0= confirm  \ input error
    1 0 GCF .s 1 = confirm  \ exit case
    0 1 GCF .s 1 = confirm  \ rev exit
    2 1 GCF .s 1 = confirm  \ n1 > n2
    1 2 GCF .s 1 = confirm  \ n1 < n2
    1 1 GCF .s 1 = confirm
    -1 1 GCF .s 1 = confirm
    1 -1 GCF .s 1 = confirm
    -1 -1 GCF .s 1 = confirm
    2 2 GCF .s 2 = confirm  \ n1 = n2
    -2 2 GCF .s 2 = confirm  \ -n1 = n2
    2 -2 GCF .s 2 = confirm  \ n1 = -n2
    2 4 GCF .s 2 = confirm
    4 2 GCF .s 2 = confirm
    -2 4 GCF .s 2 = confirm
    4 -2 GCF .s 2 = confirm
    2 -4 GCF .s 2 = confirm
    -4 2 GCF .s 2 = confirm
    65536 256 GCF .s 256 = confirm
    65537 257 GCF .s 1 = confirm
    2147483645 6289 GCF .s 19 = confirm
  #+end_src

- LCM “Least Common Multiple” ::
  Find the positive least common multiple of two signed non-zero
  integers. If either input is zero, making GCF 0, return 0.

  #+begin_src forth :tangle rat-math-lib.fs
    : LCM ( n1 n2 -- n ) \ rational "Least Common Multiple"
      \ Return the positive signed integer least common multiple of two signed non-zero integers.
      2dup GCF
      dup
      if  \ if GCF <> 0
	,*/ abs
      else
	drop 2drop 0  \ error: cleanup, return 0
      then ;
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
    0 0 LCM .s 0= confirm  \ input error
    1 0 LCM .s 0= confirm  \ GCD exit case
    0 1 LCM .s 0= confirm  \ GCD rev exit case
    2 1 LCM .s 2 = confirm
    1 2 LCM .s 2 = confirm
    1 1 LCM .s 1 = confirm
    1 -1 LCM .s 1 = confirm
    -1 1 LCM .s 1 = confirm
    65537 257 LCM .s 16843009 = confirm
  #+end_src

- CTZ “Count Trailing Zeros” ::
  Count trailing zeros. (see [[https://en.wikipedia.org/wiki/Find_first_set][Find First Set]]). Given a 32-bit positive
  signed integer (0 sign bit), count the number of trailing zero bits.

  |                            given | returns |
  |----------------------------------+---------|
  | 0xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx1 |       0 |
  | 0xxxxxxxxxxxxxxxxxxxxxxxxxxxxx10 |       1 |
  | 0xxxxxxxxxxxxxxxxxxxxxxxxxxxx100 |       2 |
  | 0x100000000000000000000000000000 |      29 |
  | 01000000000000000000000000000000 |      30 |
  | 10000000000000000000000000000000 |      31 |
  | 00000000000000000000000000000000 |      32 |

  #+begin_src forth :tangle rat-math-lib.fs
    : CTZ ( w -- u ) \ rational "Count Trailing Zeros"
	  \  Count trailing zero bits of an single integer, returning int
      dup negate and  \ isolate trailing 1-bit
      32 swap  \ initialize count to 32
      dup if swap 1- swap then
      dup $0000FFFF and if swap 16 - swap then
      dup $00FF00FF and if swap 8 - swap then
      dup $0F0F0F0F and if swap 4 - swap then
      dup $33333333 and if swap 2 - swap then
      dup $55555555 and if swap 1- swap then
      drop ;  \ drop the input
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
    0 CTZ .s 32 = confirm
    $80000000 CTZ .s 31 = confirm
    $40000000 CTZ .s 30 = confirm
    $60000000 CTZ .s 29 = confirm
    $70000000 CTZ .s 28 = confirm
    1 CTZ .s 0= confirm
    2 CTZ .s 1 = confirm
    12 CTZ .s 2 = confirm
  #+end_src

** Variables and Constants

- rConstant ::
  Allocate and initialize a 2-cell rational constant from the stack.

  The name of the new constant subsequently returns the value of the
  constant.

  #+begin_src forth :tangle rat-math-lib.fs
    : ratConstant ( num den "name" -- ) \ rational "rat-constant"
      \ Allocate and initialize a rational constant word
      create 2,
    does> ( -- num den )
      2@ ;
  #+end_src

- Useful constants ::
  Define several useful constants

  #+begin_src forth :tangle rat-math-lib.fs
    0 1 ratConstant ratZero  \ Zero or Positive Zero
    0 -1 ratConstant ratNegZero  \ Negative Zero
    1 0 ratConstant ratPosInf  \ Positive Infinity
    -1 0 ratConstant ratNegInf  \ Negative Infinity
    0 0 ratConstant ratNaN  \ Not-a-Number
    1 1 ratConstant ratPosOne  \ +1
    -1 1 ratConstant ratNegOne  \ -1
    2147483647 1 ratConstant ratPosMax  \ Positive Max
    -2147483648 1 ratConstant ratNegMax  \ Negative Max
    1 2147483647 ratConstant ratPosMin  \ Positive Min
    -1 2147483647 ratConstant ratNegMin  \ Negative Min
    355 113 ratConstant ratPi6  \ pi to 6 decimal places
    104348 33215 ratConstant ratPi9  \ pi to 9 decimal places
    1264 465 ratConstant ratE6  \ e to 6 decimal places
    23225 8544 ratConstant ratE9  \ e to 9 decimal places
  #+end_src

  Works for:
  - [X] +0
  - [X] -0
  - [X] +Inf
  - [X] -Inf
  - [X] NaN
  - [X] +1
  - [X] -1
  - [X] +2147483647
  - [X] -2147483648
  - [X] +1/2147483647
  - [X] -1/2147483647
  
  Tests:
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
    ratZero .s 2drop  \ <2> 0 1 =
    ratNegZero .s 2drop  \ <2> 0 -1 =
    ratPosInf .s 2drop  \ <2> 1 0 =
    ratNegInf .s 2drop  \ <2> -1 0 =
    ratNaN .s 2drop  \ <2> 0 0 =
    ratPosOne .s 2drop  \ <2> 1 1 =
    ratNegOne .s 2drop  \ <2> -1 1 =
    ratPosMax .s 2drop  \ <2> 2147483647 1 =
    ratNegMax .s 2drop  \ <2> -2147483648 1 =
    ratPosMin .s 2drop  \ <2> 1 2147483647 =
    ratNegMin .s 2drop  \ <2> -1 2147483647 =
    ratPi6 .s 2drop  \ <2> 355 113 =
    ratPi9 .s 2drop  \ <2> 104348 33215 =
    ratE6 .s 2drop  \ <2> 1264 465 =
    ratE9 .s 2drop  \ <2> 23225 8544 =
  #+end_src

- ratVariable ::
  Allocates a 2-cell rational variable to store one single signed integer
  numerator and one single signed integer denominator.  The variable
  is initialized to zero, with a numerator of 0 and a denominator of 1.

  The name of the new variable subsequently returns the address of the
  variable.
  
  #+begin_src forth :tangle rat-math-lib.fs
    : ratVariable ( “name” -- a-addr ) \ rational "rat-variable"
      \ Allocate and initialize a rational variable to zero.
      create RatZero 2, ;  \ Initialize to rational 0/1
  #+end_src

- rat@ “rat fetch” ::
  Fetch a rational variable from the given address and return it as
  numerator, then denominator.

  When rational numbers are fetched from a variable to the stack, the
  denominator is fetched from the cell at the given address, followed
  by the numerator from the next cell.

  “rat@” is an alias of  “2@”.
  
  #+begin_src forth :tangle rat-math-lib.fs
    \ : rat@ ( -- num den ) \ rational "rat-fetch"
      \ rat@ is identical to 2@
      ' 2@ Alias rat@
  #+end_src

- rat! “rat store” ::
  Store a rational number at the given address.

  When rational numbers are stored from the stack to an address
  (usually of a variable), the denominator is stored in the cell at
  the given address and the numerator is stored in the next cell.

  “rat!” is an alias of “2!”.

  #+begin_src forth :tangle rat-math-lib.fs
    \ : rat! ( num den -- ) \ rational "rat-store"
      \ rat! is identical to 2!
      ' 2! Alias rat!
  #+end_src

Tests:
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
    ratVariable rx .s
    rx .s
    rat@ .s 0 1 2= confirm
    -2 3 rx rat! .s
    rx rat@ .s -2 3 2= confirm
    -2147483648 2147483647 rx rat! .s
    rx rat@ .s -2147483648 2147483647 2= confirm
  #+end_src

** Conversions

- n>rat “n to rat” ::
  Convert single signed integer to rational by appending a denominator
  of 1.

  #+begin_src forth :tangle rat-math-lib.fs
    : n>rat ( n -- num 1 )
      \ Convert a single signed integer to rational
      1 ;
  #+end_src

  Works for:
  - [X] +0
  - [-] -0
  - [-] +Inf
  - [-] -Inf
  - [-] NaN
  - [X] +1
  - [X] -1
  - [X] +2147483647
  - [X] -2147483648
  - [-] +1/2147483647
  - [-] -1/2147483647

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
    0 n>rat .s 2drop  \ <2> 0 1 =
    1 n>rat .s 2drop  \ <2> 1 1 =
    -1 n>rat .s 2drop  \ <2> -1 1 =
    2147483647 n>rat .s 2drop  \ <2> 2147483647 1 =
    -2147483647 n>rat .s 2drop  \ <2> -2147483647 1 =
  #+end_src

- 1/n>rat “inverse n to rat” ::
  Invert a single signed integer, converting to rational by prepending
  a numerator of 1.

  #+begin_src forth :tangle rat-math-lib.fs
    : 1/n>rat ( n -- 1 den )
      \ Invert a single signed integer, converting to rational
      1 swap ;
  #+end_src

  Works for:
  - [-] +0
  - [-] -0
  - [X] +Inf
  - [-] -Inf
  - [-] NaN
  - [X] +1
  - [X] -1
  - [-] +2147483647
  - [-] -2147483648
  - [X] +1/2147483647
  - [X] -1/2147483647

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
    0 1/n>rat .s 2drop  \ <2> 1 0 =
    1 1/n>rat .s 2drop  \ <2> 1 1 =
    -1 1/n>rat .s 2drop  \ <2> 1 -1 =
    2147483647 1/n>rat .s 2drop  \ <2> 1 2147483647 =
    -2147483647 1/n>rat .s 2drop  \ <2> 1 -2147483647 =
  #+end_src

- rat>n ::
  Convert a rational number to single precision signed integer.

  “rat>n” is an alias of “/”. Rounding is toward negative infinity by
  default (i.e. floor), not the closest integer.

  Use “swap s>d swap sm/rem” for symmetric division with remainder.
  
  #+begin_src forth :tangle rat-math-lib.fs
    ' / Alias rat>n  \ rat>n is an alias of /
  #+end_src

  Works for:
  - [X] +0
  - [X] -0
  - [-] +Inf
  - [-] -Inf
  - [-] NaN
  - [X] +1
  - [X] -1
  - [X] +2147483647
  - [X] -2147483648
  - [X] +1/2147483647
  - [X] -1/2147483647

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
    RatZero rat>n .s drop  \ <1> 0 =
    RatNegZero rat>n .s drop  \ <1> 0 =
    RatPosOne rat>n .s drop \ <1> 1 =
    RatNegOne rat>n .s drop  \ <1> -1 =
    ratPosMax rat>n .s drop  \ <1> 2147483647 =
    ratNegMax rat>n .s drop  \ <1> -2147483648 =
    ratPosMin rat>n .s drop  \ <1> 0 =
    ratNegMin rat>n .s drop  \ <1> -1 =
    1 2 rat>n .s drop  \ <1> 0 =
    1 3 rat>n .s drop  \ <1> 0 =
    2 3 rat>n .s drop  \ <1> 0 =
    3 2 rat>n .s drop  \ <1> 1 =
    3 3 rat>n .s drop  \ <1> 1 =
    -1 2 rat>n .s drop  \ <1> -1 =
    -1 3 rat>n .s drop  \ <1> -1 =
    -2 3 rat>n .s drop  \ <1> -1 =
    -3 2 rat>n .s drop  \ <1> -2 =
    -3 3 rat>n .s drop  \ <1> -2 =
  #+end_src

- rat>f ::
  Convert a rational number to floating point.

  #+begin_src forth :tangle rat-math-lib.fs
    : rat>f ( num den -- ) ( F: -- f )
      \ Convert a rational number to floating point
      2dup 0< swap 0= and
      if  \ is 0/neg aka -0
	2drop -0.0e0  \ handle -0e0 case
      else
	swap s>f s>f f/  \ s>f moves ints to float stack, reversing order.
      then ;
  #+end_src

  Works for:
  - [X] +0
  - [ ] -0
  - [X] +Inf
  - [X] -Inf
  - [X] NaN
  - [X] +1
  - [X] -1
  - [X] +2147483647
  - [X] -2147483648
  - [X] +1/2147483647
  - [X] -1/2147483647

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s ." F: " f.s  \ <0> F: <0> =
    ratZero rat>f .s ." F: " f.s fdrop  \ <0> F: <1> 0.000000000000E0 =
    ratNegZero rat>f f>rat .s ." F: " f.s 2drop  \ <0> 0 -1 F: <0> =
    ratPosInf rat>f .s ." F: " f.s fdrop  \ <0> F: <1> inf =
    ratNegInf rat>f .s ." F: " f.s fdrop  \ <0> F: <1> -inf =
    ratNaN rat>f .s ." F: " f.s fdrop  \ <0> F: <1> -nan =
    ratPosOne rat>f .s ." F: " f.s fdrop  \ <0> F: <1> 1.000000000000E0 =
    ratNegOne rat>f .s ." F: " f.s fdrop  \ <0> F: <1> -1.00000000000E0 =
    ratPosMax rat>f .s ." F: " f.s fdrop  \ <0> F: <1> 2147483647.00000 =
    ratNegMax rat>f .s ." F: " f.s fdrop  \ <0> F: <1> -2.14748364800E9 =
    ratPosMin rat>f .s ." F: " f.s fdrop  \ <0> F: <1> 4.6566128752E-10 =
    ratNegMin rat>f .s ." F: " f.s fdrop  \ <0> F: <1> -4.656612875E-10 =
    1 2 rat>f .s ." F: " f.s fdrop  \ <1> 0 =
    1 3 rat>f .s ." F: " f.s fdrop  \ <1> 0 =
    2 3 rat>f .s ." F: " f.s fdrop  \ <1> 0 =
    3 2 rat>f .s ." F: " f.s fdrop  \ <1> 1 =
    3 3 rat>f .s ." F: " f.s fdrop  \ <1> 1 =
    -1 2 rat>f .s ." F: " f.s fdrop  \ <1> 0 =
    -1 3 rat>f .s ." F: " f.s fdrop  \ <1> 0 =
    -2 3 rat>f .s ." F: " f.s fdrop  \ <1> 0 =
    -3 2 rat>f .s ." F: " f.s fdrop  \ <1> 1 =
    -3 3 rat>f .s ." F: " f.s fdrop  \ <1> 1 =
  #+end_src

- e8f23>rat ::
  Convert a normal float 8-bit exponent and 23-bit fraction to a
  rational number. If out of rational range, return NaN (0/0).

  #+begin_src forth :tangle rat-math-lib.fs
    : ex8f23>rat { ex8 f23 -- num den }
		\ Convert a normal IEEE float exponent and fraction to rational.
		\ ex8: 8 bit unsigned 0-255 IEEE float exponent, right justified
		\ fr23 : 23-bit unsigned float fraction (sans implied 1 in bit 24)
		\ Does not handle +/- infinity or NaN.
		\ Returns rational NaN (0/0) if out of rational range.
		f23 $00800000 or cr ." N24: " ['] .s 16 base-execute ( -- N24 )  \ attach the silent 1 at bit 24
		dup CTZ cr ." N24 tz: " ['] .s 16 base-execute ( -- N24 tz )  \ trailing zeros is 0 to 23
		$00800000 swap cr ." N24 D24 tz: " ['] .s 16 base-execute ( -- N24 D24 tz )
		drop 2drop
		;
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- f>rat “Float to Rational” ::
  Convert a floating point number to a rational number.

  #+begin_src forth :tangle rat-math-lib.fs
    variable f32ieee  \ Entire 32-bit ieee float buffer

    : f>rat ( f -- num den)
      \ Convert a floating point number to a rational number.
      f32ieee sf!  \ store the given float as 32 bits
      f32ieee @ $007FFFFF and  \ 23-bit fraction part of float, with bit 24 set
      f32ieee @ $7F800000 and 23 rshift  \ exponent of float, shifted down 23 bits.
      f32ieee @ $80000000 and  \ negative sign of float
      { f32frac f32expo f32sign }

      \ debug dumps
      ." | "
      f32sign if ." -" else ." +" then
      ." $1." f32frac hex . decimal
      ." * 2^(" f32expo . ." -127) "
      ." | "

      f32expo $FF =
      if  \ expo = special 255 ?
	f32frac
	if  \ frac <> 0 ?
	  ratNan  \ non-a-number
	else  \ +/- inf
	  f32sign
	  if  \ negative ?
	    ratNegInf
	  else
	    ratPosInf
	  then
	then
      else
	f32expo 0= f32frac 0= and
	if  \ expo = 0 and frac = 0
	  f32sign
	  if  \ negative ?
	    ratNegZero
	  else
	    ratZero
	  then
	else
	  f32expo f32frac ex8f23>rat  \ Convert normal exponent and fraction to rational
	then
      then ;
  #+end_src

  Works for:
  - [X] +0
  - [X] -0
  - [X] +Inf
  - [X] -Inf
  - [X] NaN
  - [ ] +1
  - [ ] -1
  - [ ] +2147483647
  - [ ] -2147483648
  - [ ] +1/2147483647
  - [ ] -1/2147483647

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s ." F: " f.s  \ <0> F: <0> =
    0.0e0 f.s ." -- " f>rat .s 2drop  \ <1> 0e0 -- <2> 0 1 =
    -0.0e0 f.s ." -- " f>rat .s 2drop  \ <1> 0e0 -- <2> 0 -1 =
    1.0e0 0.0e0 f/ f.s ." -- " f>rat .s 2drop  \ <1> inf -- <2> 1 0 =
    -1.0e0 0.0e0 f/ f.s ." -- " f>rat .s 2drop  \ <1> -inf -- <2> -1 0 =
    0.0e0 0.0e0 f/ f.s ." -- " f>rat .s 2drop  \ <1> nan -- <2> 0 0 =
    1.0e0 f.s ." -- " f>rat .s 2drop  \ <1> 1e0 -- <2> 1 1 =
    -1.0e0 f.s ." -- " f>rat .s 2drop  \ <1> -1e0 -- <2> -1 1 =
  #+end_src


- ratFixSign “rat fix sign” ::
  Ensure that the denominator is not negative when the numerator is non-zero.

  #+begin_src forth :tangle rat-math-lib.fs
    : ratFixSign ( num den -- nNum denen )
      \ Ensure that the denominator is not negative when the numerator is non-zero.
      dup 0<  \ denom < 0 ?
      if
	over  \ numer <> 0 ?
	if
	  swap negate swap  \ negate numer
	  negate  \ negate denom
	then
      then ;
  #+end_src

  Works for:
  - [ ] +0
  - [ ] -0
  - [ ] +Inf
  - [ ] -Inf
  - [ ] NaN
  - [ ] +1
  - [ ] -1
  - [ ] +2147483647
  - [ ] -2147483648
  - [ ] +1/2147483647
  - [ ] -1/2147483647

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
    0 1 ratFixSign .s 2drop  \ 0  <2> 0 1 =
    0 -1 ratFixSign .s 2drop  \ -1 <2> 0 -1 =
    1 0 ratFixSign .s 2drop  \ inf <2> 1 0 =
    -1 0 ratFixSign .s 2drop  \ -inf <2> -1 0 =
    0 0 ratFixSign .s 2drop  \ nan <2> 0 0 =
    1 1 ratFixSign .s 2drop  \ nan <2> 1 1 =
    -1 1 ratFixSign .s 2drop  \ nan <2> -1 1 =
    -1 -1 ratFixSign .s 2drop  \ nan <2> 1 1 =
    1 -1 ratFixSign .s 2drop  \ nan <2> -1 1 =
    2 3 ratFixSign .s 2drop  \ nan <2> 2 3 =
    -2 3 ratFixSign .s 2drop  \ nan <2> -2 3 =
    -2 -3 ratFixSign .s 2drop  \ nan <2> 2 3 =
    2 -3 ratFixSign .s 2drop  \ nan <2> -2 3 =
  #+end_src

- ratReduce “rat reduce” ::
  Reduce the fraction to an equivalent one with the lowest terms by
  dividing both numerator and denominator by their greatest common
  factor, if the GCF is greater than one.

  #+begin_src forth :tangle rat-math-lib.fs
    : ratReduce ( num den -- num1 den1 )
      \ if both terms are non-zero and the GCF is > 1, reduce to lowest terms.
      dup  \ numer <> 0 ?
      if
	over  \ denom <> 0 ?
	if
	  2dup GCF  \ find GCF (which is positive)
	  dup 1-  \ GCF > 1 ?
	  if ( -- num den GCF )
	    dup -rot ( -- num GCF den GCF )
	    2swap / -rot  \ numer=numer/GCF ( -- num1 den GCF )
	    /  \ denom=denom/GCF ( -- num1 den1 )
	  else
	    drop  \ drop GCF of 1
	  then
	then
      then ;
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- ratNormal “rat normalize” ::

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

** Operations

- rat+ “rat plus” ::

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- rat1+ “rat one plus” :: 

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- rat- “rat minus” ::

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- rat1- “rat 1 minus” :: 

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- rat* “rat star” ::

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- rat/ “rat slash” ::

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- ratNegate “rat negate” ::

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- ratAbs “rat abs” ::

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- ratMin “rat min” ::

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

- ratMax “rat max” :: 

  #+begin_src forth :tangle rat-math-lib.fs
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src

** Comparisons

- rat= “rat-equals” ::

  #+begin_src forth :tangle rat-math-lib.fs
    : rat= ( num1 den1 num2 den2 -- f ) \ rational "rat-equals"
      \ compare 1st rational with 2nd ration for equality
      \ normalizes both rational, then double-tests for equality
      \ 2swap ratNormal 2swap ratNormal
      swap -rot = -rot = and ;
  #+end_src

  Tests:  
  #+begin_src forth :tangle rat-math-lib-tests.fs
    .s  \ <0> =
  #+end_src
